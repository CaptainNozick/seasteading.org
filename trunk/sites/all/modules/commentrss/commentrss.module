<?php
// $Id: commentrss.module,v 1.12.2.2 2007/07/16 04:19:11 tangent Exp $

/**
 * @file
 * Publishes RSS feeds for comments.
 */

/**
 * Implementation of hook_help().
 */
function commentrss_help($section) {
  $output = '';
  switch ($section) {
    case 'admin/modules#description':
      $output = t('Provides RSS feeds for comments');
      break;
    case 'admin/content/commentrss':
      $output = '<p>' . t('Select the types of comment feeds to be enabled.') . '</p>';
      break;
    case 'admin/help#commentrss':
      $output = '<p>' . t('The commentrss module provides RSS feeds for comments. Comment feeds are published on pages which also provide a feed of nodes. Some comment feeds may be disabled if the are not needed.') . '</p>';
      $output .= '<p>' . t('If comment feeds are enabled for individual nodes then a "wfw:commentRss" element is added to node feeds so that aggregators may discover the corresponding comment feed.') . '</p>';
      $output .= '<p>' . t('If the !link module is installed then a comment feed will be added to complement the node feed provided by that module.', array('!link' => l('vocabulary_list', 'http://drupal.org/project/vocabulary_list'))) . '</p>';
      break;
  }
  return $output;
}

/**
 * Implementation of hook_menu().
 */
function commentrss_menu($may_cache) {
  $items = array();
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/content/commentrss',
      'title' => t('Comment RSS publishing'),
      'description' => t('Configure RSS feeds for comments.'),
      'callback' => 'drupal_get_form',
      'callback arguments' => 'commentrss_admin_settings',
      'access' => user_access('administer site configuration'),
      'type' => MENU_NORMAL_ITEM);
    $items[] = array('path' => 'crss', 'title' => '',
      'callback' => 'commentrss_handler',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK);
  }
  else {
    if (arg(0) == 'node' && is_numeric(arg(1)) && variable_get('commentrss_node', TRUE)) {
      $node = node_load(arg(1));
      if ($node->nid && $node->comment != COMMENT_NODE_DISABLED) {
        drupal_add_feed(url('crss/node/'. $node->nid),
          t('Comments for @title', array('@title' => $node->title)));
      }
    }
    elseif (arg(0) == 'node' && variable_get('commentrss_site', TRUE)) {
      drupal_add_feed(url('crss'),
        t('@site - All comments', array('@site' => variable_get('site_name', 'Drupal'))));
    }
    elseif (arg(0) == 'taxonomy' && arg(1) == 'term' && is_numeric(arg(2)) && variable_get('commentrss_term', FALSE)) {
      $term = taxonomy_get_term(arg(2));
      if ($term->tid) {
        drupal_add_feed(url('crss/term/'. $term->tid),
          t('Comments for category "@title"', array('@title' => $term->name)));
      }
    }
    elseif (arg(0) == 'taxonomy' && arg(1) == 'vocabulary' && is_numeric(arg(2)) && variable_get('commentrss_node', FALSE)) {
      // vocabulary_list module is serving this page
      drupal_add_feed(url('crss/vocab/'. arg(2)), t('Comments for this vocabulary'));
    }
  }
  return $items;
}

/**
 * Menu callback; publish an RSS feed
 */
function commentrss_handler($type = 'site') {
  if ($type && variable_get('commentrss_'. $type, FALSE)) {
    if (call_user_func('commentrss_feed_'. $type)) {
      return;
    }
  }
  drupal_not_found();
}

/**
 * Publish a feed for all comments
 */
function commentrss_feed_site() {
  $items = commentrss_format_items('n.nid');
  commentrss_format_feed($items);
  return TRUE;
}

/**
 * Publish a feed for all comments of a specified node
 */
function commentrss_feed_node() {
  global $base_url;

  if (is_numeric(arg(2))) {
    $node = node_load(arg(2));
    if ($node->nid) {
      $items = commentrss_format_items('n.nid', '', 'n.nid = %d AND', $node->nid);
      $extra_defaults = array(
        array('key' => 'pubDate', 'value' => date('r', $node->created)),
        array('key' => 'dc:creator', 'value' => $node->name),
        array('key' => 'guid', 'attributes' => array('isPermaLink' => 'false'),
                'value' => url('node/'. $node->nid))
      );
      $extra = node_invoke_nodeapi($node, 'rss item');
      $extra = array_merge($extra, $extra_defaults);
      $namespaces = array();
      foreach ($extra as $element) {
        if ($element['namespace']) {
          $namespaces[] = $element['namespace'];
        }
      }
      $channel = array(
        'title' => t('@site - Comments for "@title"', array(
                       '@site' => check_plain(variable_get('site_name', 'Drupal')),
                       '@title' => check_plain($node->title))),
        'description' => t('Comments for "@title"', array('@title' => $node->title)),
        'link' => url('node/'. $node->nid, NULL, NULL, TRUE),
      );

      commentrss_format_feed($items, $channel, $namespaces);
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Publish a feed for all comments with a specified term
 */
function commentrss_feed_term() {
  if (is_numeric(arg(2))) {
    $term = taxonomy_get_term(arg(2));
    if ($term->tid) {
      $items = commentrss_format_items('DISTINCT(n.nid)', 'INNER JOIN {term_node} r ON n.nid = r.nid', 'r.tid = %d AND', $term->tid);
      $channel = array(
        'title' => t('@site - Comments for "@term"', array(
                       '@site' => check_plain(variable_get('site_name', 'Drupal')),
                       '@term' => check_plain($term->name))),
        'description' => t('Comments for the category "@term"', array('@term' => $term->name)),
        'link' => url('taxonomy/term/'. $term->tid, NULL, NULL, TRUE),
      );

      commentrss_format_feed($items, $channel);
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Publish a feed for all comments with any term in a specified vocabulary
 * 
 * Requires vocabulary_list.module
 */
function commentrss_feed_vocab() {
  if (module_exists('vocabulary_list') && is_numeric(arg(2))) {
    $vocab = taxonomy_get_vocabulary(arg(2));
    if ($vocab->vid) {
      $items = commentrss_format_items('DISTINCT(n.nid)', 'INNER JOIN {term_node} r ON n.nid = r.nid INNER JOIN {term_data} d ON r.tid = d.tid', 'd.vid = %d AND', $vid);
      $channel = array(
        'title' => t('@site - Comments for "@vocab"', array(
                       '@site' => check_plain(variable_get('site_name', 'Drupal')),
                       '@vocab' => check_plain($vocab->name))),
        'description' => t('Comments for all categories in "@vocab"', array('@vocab' => $vocab->name)),
        'link' => url('taxonomy/vocabulary/'. $vocab->vid, NULL, NULL, TRUE),
      );

      commentrss_format_feed($items, $channel);
      return TRUE;
    }
  }
  return FALSE;
}

/**
 *  Format and print a comment feed
 */
function commentrss_format_feed($items, $channel = array(), $namespaces = array()) {
  global $base_url, $locale;
  
  $channel_defaults = array(
    'version'     => '2.0',
    'title'       => check_plain(variable_get('site_name', 'Drupal')) .' - '. t('Comments'),
    'link'        => $base_url,
    'description' => t('Comments'),
    'language'    => $locale
  );
  $channel = array_merge($channel_defaults, $channel);
  $namespaces = array_merge(array('xmlns:dc="http://purl.org/dc/elements/1.1/"'), $namespaces);
  
  $output = '<?xml version="1.0" encoding="utf-8"?>'."\n";
  $output .= '<rss version="'. $channel['version'] .'" xml:base="'. $base_url .'" '. implode(' ', $namespaces) . ">\n";
  $output .= format_rss_channel($channel['title'], $channel['link'], $channel['description'], $items, $channel['language']);
  $output .= "</rss>\n";

  drupal_set_header('Content-Type: application/rss+xml; charset=utf-8');
  print $output;
}

/**
 * Format RSS for comments sent in reply to the nodes selected by the given SQL selector
 */
function commentrss_format_items($nidselector, $joins = '', $where = '', $param = NULL) {
  global $base_url;

  $items = '';

  // Build SQL query from the passed elements
  $SQL = 'SELECT '. $nidselector .', c.cid, c.subject, c.comment, c.timestamp, c.uid, c.name, c.format FROM {node} n ' . $joins . ' INNER JOIN {comments} c ON c.nid = n.nid WHERE ' . $where . ' n.status = 1 AND c.status = %d ORDER BY c.timestamp DESC';

  // Add passed query parameter; plus we are looking for published comments
  $params = isset($param) ? array($param) : array();
  $params[] = COMMENT_PUBLISHED;

  $comments = db_query_range(db_rewrite_sql($SQL), $params, COMMENT_PUBLISHED, 0, 15);
  while ($comment = db_fetch_object($comments)) {
    if ($comment->uid) {
      if ($user = user_load(array('uid' => $comment->uid))) {
        $comment->name = $user->name;
      }
    }
    if (!$comment->name) {
      $comment->name = variable_get('anonymous', 'Anonymous');
    }
    $extra = array(array('key' => 'pubDate', 'value' => date('r', $comment->timestamp)), array('key' => 'dc:creator', 'value' => $comment->name), array('key' => 'guid', 'value' => 'comment ' . $comment->cid . ' at ' . $base_url, 'attributes' => array('isPermaLink' => 'false')));
    $link = url("node/{$comment->nid}", NULL, "comment-{$comment->cid}", TRUE);
    $items .= format_rss_item($comment->subject, $link, check_markup($comment->comment, $comment->format, FALSE), $extra);
  }
  return $items;
}

/**
 * Implementation of hook_nodeapi().
 */
function commentrss_nodeapi(&$node, $op) {
  if ($op == 'rss item') {
    // Add a wfw:commentRss element to node feed entries if:
    //   node comments are enabled for the node
    //   comment feeds for individual nodes are enabled
    if ($node->comment != COMMENT_NODE_DISABLED && variable_get('commentrss_node', TRUE)) {
      // The "wfw" namespace is added to each element due to a bug in node_feed().
      // See http://drupal.org/node/157709
      return array(array(
        'key' => 'wfw:commentRss',
        'attributes' => array('xmlns:wfw' => 'http://wellformedweb.org/CommentAPI/'),
        'value' => url('crss/node/'. $node->nid, NULL, NULL, TRUE)));
    }
  }
}

/**
 * Menu callback; displays the commentrss module settings page.
 */
function commentrss_admin_settings() {
  $form['commentrss_site'] = array('#type' => 'checkbox',
    '#title' => t('Node comments for entire site'),
    '#default_value' => variable_get('commentrss_site', FALSE));
  $form['commentrss_node'] = array('#type' => 'checkbox',
    '#title' => t('Node comments for individual nodes'),
    '#default_value' => variable_get('commentrss_node', FALSE));
  $form['commentrss_term'] = array('#type' => 'checkbox',
    '#title' => t('Node comments for a term'),
    '#default_value' => variable_get('commentrss_term', FALSE));
  if (module_exists('vocabulary_list')) {
    $form['commentrss_vocab'] = array('#type' => 'checkbox',
      '#title' => t('Node comments for a vocabulary'),
      '#default_value' => variable_get('commentrss_vocab', FALSE));
  }

  return system_settings_form($form);
}
